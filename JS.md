## JS基础

做程序员必做50题

《JavaScript高级程序设计》第4版

 链接：https://pan.baidu.com/s/1k-KXRC0p9gzz1X0xLe42Vw
 提取码：fhjj

**JS应用场景**

 JS可以开发浏览器端的交互效果

 JS还可以进行服务器端开发，例如：访问数据库、调用其它服务器..

**搭建开发环境**

 1.浏览器

 浏览器内部都有自带的JS解释器，可以执行JS代码

 内核

 谷歌/火狐/Safari/edge/欧朋

 2.Node.js

 JS在服务器端的运行环境

 www.nodejs.org

 打开命令行   node -v

 3.运行JS

 (1)浏览器

  创建01.js和01.html文件，在html中编写代码，将js嵌入进去

| <script src="01.js"></script> |
| ----------------------------- |

(2)Node.js

  在命令行cmd下

  node  拖拽要运行的文件   回车

**JS的语法规范**

 区分大小写

 每行代码结束的分号可以省略

 分为单行注释(//..)和多行注释(/*…*/)

**变量**用于存储数据的容器

 1.声明变量

 var x=1

 使用var关键字声明变量，会在内存中开辟空间，命名为x

 var a=1, b=2;

 一个var关键字可以声明多个变量，多个之间用逗号隔开

 2.变量命名规则

 变量名称可以由英文字母、数字、下划线、美元符号组成，数字不能出现在开头，不能使用关键字；汉字也不推荐使用。

 尽量使用英文单词，有多个单词，建议将后边单词首字母大写

 email  user_name  userName

 3.变量赋值

 变量声明后未赋值为undefined(未定义)，变量可以多次赋值，赋不同类型的值，这个是弱类型语言特点。

**常量**用来存储数据

 const a=1

 特点：声明后必须赋值，不允许重新赋值

 练习：声明变量保存圆的半径，声明常量保存圆周率，声明多个变量保存计算的圆的周长和面积并输出。

**数据类型**分为原始类型和引用类型

 原始类型分为数值型、字符串型、布尔型、未定义型、空

 1.数值型

 就是数字，分为整型和浮点型

 1  2  3  4  5  6  7  8  9  10 ... 15 16

 8进制

 1  2  3  4  5  6  7 10 11 12

 16进制

 1  2  3  4  5  6  7  8  9  a ... f  10

 8进制以0开头的数字，例如：010

 16进制以0x开头的数字，例如：0xa  其中不区分大小写

 浮点型

 31.4

 3.14e+1

 0.314e+2

  typeof 值   检测一个值的数据类型    

 2.字符串型

 被引号所包含的数据就是字符串型，不区分单双引号

 查看任意一个字符的Unicode编码

  'a'.charCodeAt()

 3.布尔型

 只有两个值，分别是true和false，代表真和假

 用于保存只有两个值的数据，例如：是否登录，是否为会员...

 一些运算结果也是布尔型的值

 4.未定义型

 只有一个值undefined，表示空值，声明了变量未赋值为undefined

 5.空

 只有一个值null，类型是对象，常和对象一起使用。

**数据类型转换**分为隐式转换和强制转换

 1.隐式转换

 在运算过程中自动产生的转换

 (1)数字+字符串  数字转换为字符串

  2+'3' // '23'

 (2)数字+布尔型  布尔型转换为数字，true->1 false->0

  2+true //3

  2+false //2

 (3)字符串+布尔型  布尔型转换为字符串

  '2'+true //'2true'

  **加号(+)的作用**  (1)执行数值间的加法运算  (2)执行字符串间的拼接  

 NaN：Not a Number，不是一个数字，只有在将一个值转为数值的时候，没有成功的得到数字，结果是NaN，NaN和任何值执行数学运算结果还是NaN

 所有的隐式转换都会自动的调用函数Number()

 2.强制转换

 (1)转换为数值

  Number()

  Number('3')  //3  Number('3a')  //NaN  Number(true)  //1  Number(false)  //0  Number(undefined)  //NaN  Number(null)  //0  

 (2)强制转换为整型

  parseInt()

  用于将小数和字符串转为整型，其它的转换结果为NaN

  parseInt(5.9)  //5  parseInt('3c88') //3  parseInt('c3')  //NaN  

 (3)强制转换为小数

  parseFloat()

  用于将字符串转换为小数，其它的转换的结果是NaN

  parseFloat('6.18a')  //6.18  parseFloat('3c')  //3  parseFloat('c3')  //NaN  

 (4)强制转换为字符串(了解)

  只能用于将数字和布尔型转字符串

  var  n=2;  n.toString(); //'2'  

**运算符**

 表达式：由数据本身或者由运算符连接的数据组成的形式

 运算符分为算术运算符、比较运算符、逻辑运算符、位运算符、赋值运算符、三目运算符

 1.算术运算符

  \+ - * / % ++ --

 % 取余

 ++ 自增，在原来基础上加1

 -- 自减，在原来基础上减1

| var  a2=3;  //后置赋值：先把a2的值赋给a3，然后a2再执行自增  var  a3=a2++; |
| ------------------------------------------------------------ |
| var  b2=3;  //前置赋值：先让b2执行自增，然后把自增结果赋给b3  var  b3=++b2; |

 查看以下程序的运行结果    

  var n1=5;

  var n2=n1--;

  var n3=--n1;

  console.log(n1,n2,n3);

 2.比较运算符

 \> < >= <= ==(等于) !=(不等于) ===(全等于) !==(不全等于)

 == 只是比较两个值是否相同，会产生隐式转换

 === 不仅比较值，还会比较类型，要求两者都相同

数字和字符串比较，字符串隐式转换为数字

 NaN和任何值比较(> < >= <= == ===)都是false

 字符串之间比较，比较的字符的编码，默认比较第1个字符的，如果相同继续比较后边的

3.逻辑运算符

 && 逻辑与(并且)，关联的两个条件都是true，结果是true

 || 逻辑或(或者)，关联的两个条件有一个是true，结果是true

 ! 逻辑非(取反)

 短路逻辑：当执行完第一个表达式，不再执行第二个表达式，就是短路逻辑

  && 当第一个条件为false，就不再执行第二个条件

  ||  当第一个条件为true，就不再执行第二个条件

| 短路逻辑主要就是查看第二个表达式是否执行 |
| ---------------------------------------- |

4.位运算符

模拟计算机底层的运算方式，先把值转为2进制再进行运算，最后再把运算结果转成10进制

 1  2  3  4  5  6   7

 1  10 11 100 101 110 111 

 

 & 按位与，上下两位比较，都是1结果是1，否则是0

 |  按位或，上下两位比较，含有1结果是1，否则是0

 ^ 按位异或，上下两位比较，不同是1，否则是0

 \>> 按位右移，删除最后的位数；每移动1位在原来基础上除以2，如果是小数再取整

 << 按位左移，在末尾补0；每移动1位在原来基础上乘以2

 14>>2   2<<2 

 1110    10

   11   1000

 3&5   5|7   8^13  

 011   101   1000

 101   111   1101

———  ———   ———

 001   111   0101

  1    7     5

5.赋值运算符

=   +=  -=  *=  /=  %= ..

​    运算赋值：先执行运算，再执行赋值

6.三目运算符

也称作条件运算符，根据条件选择执行对应的表达式

 一目运算符：由一个运算符连接了一个表达式   ++  --  !

 二目运算符：由一个运算符连接了两个表达式  

 三目运算符：由两个运算符连接了三个表达式

| 条件表达式  ? 表达式1 : 表达式2 |
| ------------------------------- |

 当条件表达式为true，选择执行表达式1

 当条件表达式为false，选择执行表达式2

![image-20220601171752199](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601171752199.png)



**浏览器端函数**

alert() 弹出警示框

 prompt()  弹出提示框(输入框)，需要使用变量保存用户输入的值，类型是字符串，点击取消返回的是null

程序=数据 + 算法

程序的运行方式分为顺序执行、选择执行、循环执行

**流程控制**

1.if语句

​                   ![image-20220601165457137](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601165457137.png)    

  if(条件表达式){   语句块  }  

 如果语句块中只有一行代码，则大括号可以省略

 以下数据作为条件隐式转换为false：0 NaN '' undefined null

 2.if-else语句

  if(条件表达式){   语句块1  }else{   语句块2  }  

if-else嵌套

![image-20220601165537538](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601165537538.png)

if(条件表达式1){

 语句块1

}else if(条件表达式n){

 语句块n

}else{

 语句块n+1 //以上所有的条件表达式都是false

}

3.switch-case语句：是一种特殊的多项判断语句

switch(表达式){

 case 值1:  //如果表达式和值1相同

  语句块1

  break; //结束，跳出整个switch语句

 case 值n:

  语句块n

  break;

 default: 

  语句块n+1 //表达式和每个值比较都不相同

}

switch后的表达式在和case后的值比较的过程中只有全等于(===)一种方式

**循环**

 循环：一遍又一遍的执行相同或者相似的代码

 循环的要素

  循环条件：控制循环是否往后执行

  循环体：要重复执行的代码

 1.while循环

![image-20220601165645988](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601165645988.png)

while(循环条件){

 循环体

}

2.break：在循环体中使用，用于强制结束循环，不再执行任何循环中的代码

3.do-while循环

![image-20220601165715450](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601165715450.png)

do{

 循环体

}while(循环条件);

 4.for循环

![image-20220601165733763](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601165733763.png)

for(初始值;循环条件;增量){

 循环体

}

5.continue：在循环体中使用，用于跳过剩余部分的循环体，还会继续往后执行

 常用于排除循环中某一部分值

循环嵌套：在一个循环的内部有出现了其它的循环

**函数**

Number()/parseInt()/parseFloat()/alert()/prompt()…

 函数分为系统函数和自定义函数

 函数：是一个功能体，提供若干个数据，返回处理的结果 —— 用于封装重复执行的代码

 1.创建函数

function 函数名称(){

 函数体 —— 封装的要重复执行的代码

}

 函数体中的代码需要调用才会执行

 调用

   函数名称()

 2.创建带有参数的函数

  function  函数名称(参数列表){   //用于接收外部传递的值   函数体  }  

 调用

  函数名称(参数列表) //实际传递的值

 创建函数时的参数称作形参，调用函数时的参数称作实参，实参会赋值给形参，实参的数量可以和形参的数量不匹配，如果形参未被赋值则为undefined。

 3.创建带有参数的函数

  function  函数名称(参数列表){   函数体   return 值; //返回值，返回函数调用的结果  }  

 调用

  函数名称(参数列表) //得到返回的结果

**return用于返回函数调用的结果**

**一旦return执行，就会结束函数体的执行**

**函数中没有return或者return后不加值结果都是undefined**

| **对比return和break**                      |
| ------------------------------------------ |
| return用于函数中，结束函数体的执行         |
| break用于循环和switch-case，结束对应的语句 |

**变量的作用域**

 全局作用域：函数以外就是全局作用域

 函数作用域：函数以内就是函数作用域

 全局变量：全局作用域下声明的变量，可以在任意作用域下访问

 局部变量：函数作用域下声明的变量，只能在所在的函数作用域下访问

| 函数内不加var声明的变量是全局变量                            |
| ------------------------------------------------------------ |
| 程序执行前，会将var声明的变量提升到所在作用域的最前边，只是提升声明部分，赋值不提升。 |

  **函数的作用域**

 全局函数：在全局作用域下创建的函数，可以在任意作用域下调用

 局部函数：在函数作用域下创建的函数，只能在所在的函数作用域下调用

 作用域链：作用域之间相互嵌套，查找变量的时候，先到当前作用域下查找，如果没有会一直往上一级作用域查找

 函数提升：程序执行前，会自动将函数整体提升到所在作用域的最前边，可以先写调用再写创建。

  **递归**

 在函数中调用自身这个函数，本是一种死循环，会造成内存泄漏

 使用递归：

  要有边界条件

  找规律

   使用return结束

**匿名函数**

 function(){ }

 没有名称函数

 1.创建函数

| 函数声明  function fn(){  }         |
| ----------------------------------- |
| 函数表达式  var  fun=function(){  } |

(1)**函数名称()**和**函数名称**的区别

  函数名称() 调用函数，执行函数体中的代码

  函数名称 本质是就是一个变量，保存了函数

 (2)**函数声明**和**函数表达式**创建函数的区别

  函数声明存在函数整体提升，可以先写创建再写调用

  函数表达式只是存在声明提升，必须先写创建再写调用

2.匿名函数自调用

 为了创建函数作用域，防止全局污染

  ;(function(){   //函数作用域，变量都是局部变量  })();

3.回调函数

 将函数作为参数传递

  function  tao(madai){   madai() //通过参数名称，调用传递的回调函数  }  function  xin(){  }  tao(  xin )  tao(  function(){} )  

**系统函数**

 Number()/parseInt()/parseFloat()...

 isNaN() 检测字符串中是否含有非数字，含有->true，不含有->false

​     会自动调用函数Number()转为数值，然后查看是否为NaN

 eval()  执行字符串表达式

**对象**

1.JS中的对象

 自定义对象，用户自己创建的对象

 内置对象，JS标准中提供的对象

 宿主对象，根据不同的执行环境划分，分为浏览器和Node.js两种

 2.自定义对象创建 —— 对象字面量

  {属性名:  属性值, 属性名: 属性值, .... }  

 属性名的引号可以不加，如有特殊字符必须添加

3.属性的访问

 对象.属性名

 对象['属性名']

 如果不存在的属性获取的结果为undefined

4.自定义对象创建 —— 内置构造函数

 new Object()

 创建一个空对象，需要单独的添加每一个属性；

  通过new调用的函数就是构造函数，返回一个对象

 5.遍历属性

 依次访问对象中的每一个属性

  for(var  k in   对象){   k 每个属性名   对象[k] 属性名对应的属性值  }  

 6.检测对象中是否含有某个属性

 对象.属性名===undefined  true->不存在  false->存在

 '属性名' in 对象   true->存在  false->不存在

 对象.hasOwnProperty('属性名')  true->存在  false->不存在

7.对象中的方法

 方法对应的是一个函数

  var person={   name: 'tao',   play: function(){     this //方法中的this指向的是调用方法的对象   }  }  person.play();  

**数据存储**

 原始类型的数据直接存储在栈内存

 引用类型(函数、对象、数组)的数据存储在堆内存，同时会生成地址，地址保存在栈内存。

 null，表示空地址，不指向任何的堆内存数据。

 堆内存中的数据如果不被任何的地址所指向就会销毁，只需要赋值null即可销毁

![image-20220601170809410](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20220601170809410.png)

**数组**：数组是一组数据的集合，使用为了便于操作数据；数组的每个数据称为元素。

 1.创建数组 —— 数组字面量

  [ 元素1, 元素2, ... ]

2.元素的访问

 下标：数组自动为每个元素设置的编号，从0开始的整数

 数组[下标]

 如果下标不存在则返回undefined

3.数组的长度

 数组.length  获取数组的元素个数

 (1)在数组末尾添加新的元素

  数组[ 数组.length ] = 值;

(2)清空数组

  数组.length = 0;

 4.遍历数组

 依次访问数组中的每个元素

for-in

for(var k in 数组){

 k 代表下标

 数组[k]  代表下标对应元素

}

for循环

for(var i=0;i<数组.length;i++){

 i 代表下标

 数组[i]  代表下标对应元素

}

5.创建——内置构造函数

  new Array(元素1, 元素2, ...)

  new Array(3)  创建数组初始化长度，可以添加更多个元素

 6.数组分类

  关联数组：以字符串作为下标，只能单独的添加元素

  索引数组：以>=0的整数作为下标，默认就是这种 

**对比数组和对象**

  [82,93,77,59] 是一组有序排列的

  {s1:82, s2:93, s3:77, s4:59}  是一组无序的数据

 两者都是用于存储一组数据，对象是通过属性，数组是通过元素；

 数组存储的一组数据是有序排列

 对象存储的一组数据是无序排列

7.二维数组

 数组中的元素还是数组，目的是为了对数据进行二次分类

 [ [], [], [] ]

8.API

 应用程序编程接口

 在JS下表示预定义好的函数和方法，例如parseInt()/parseFloat()/isNaN()...

 toString()  将数组转为字符串

 join('-')  将数组转为字符串，可以指定分割的字符

 concat()  拼接多个数组

slice(start, end)  截取数组元素，start开始的下标，end结束的下标，不包含end，end为空会截取到最后，下标是负数表示倒数；返回截取到的数组元素。

 splice(start, count, v1,v2..)  删除数组元素，start开始的下标，count删除的数量，count为空删除到最后，下标为负数表示倒数，v1,v2..表示删除后补充的元素，返回删除的元素，原数组会发生变化。

 reverse()  翻转数组元素，返回翻转的数组，原数组会发生变化

 sort()  对数组进行排序，默认是按照编码来排列，返回排序的数组，原数组会发生变化

  sort(  function(a,b){   return a-b;//按照数字从小到大排列   //return b-a; //按照数字从大到小排列  }  )  

 indexOf() 查找数组中是否含有某个元素，查找到返回下标，找不到返回-1

push()  在数组的末尾添加元素，返回数组长度，原数组会发生变化    

  pop()  删除数组末尾的一个元素，返回删除的元素，原数组会发生变化

  unshift()  在数组的开头添加元素，返回数组长度，原数组会发生变化

  shift()  删除数组开头的一个元素，返回删除的元素，原数组会发生变化

 

所有数组API

  https://www.w3school.com.cn/js/js_array_methods.asp  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array

 **字符串对象**

包装对象：目的是为了让原始类型的数据也具有属性和方法，JS中一共提供三种包装对象：字符串、数值、布尔

 new String() 将一个字符串包装为对象

 String() 将一个值强制转换为字符串

 1.转义字符 —— \

  转换字符本身的意义

  \'  将具有特殊意义的引号转为普通引号

  \n 将字符n转义为换行符

  \t  将字符t转义为制表符(产生多个连续的空格)

2.API

  字符串直接调用属性和方法的时候，会自动包装为对象，然后再去调用属性或者方法  

 length 获取字符串的长度

 charAt(下标)  获取一组字符串中下标对应的字符，也可以用数组方法 字符串[下标]

 indexOf() 查找字符串中是否含有某个字符串，找到返回第一次出现的下标，找不到返回-1

 lastIndexOf() 查找字符串中是否含有某个字符串，找到返回最后一次出现下标，找不到返回-1

toUpperCase() 将英文字母转大写

 toLowerCase() 将英文字母转小写

| 所有的字符串API都不会对原来的字符串产生影响 |
| ------------------------------------------- |

 slice(start, end)  截取字符串，start开始的下标，end结束的下标，不包含end本身；end为空截取到最后，如果下标为负数表示倒数，返回截取的字符串部分。

split(str)  将字符串转为数组，可以指定分割的字符

**Math对象**

提供一组数学相关的方法

 是一种特殊的对象，不需要创建对象就可以直接调用API

 PI  获取圆周率

 abs() 获取绝对值

 ceil() 向上取整

 floor() 向下取整

 round() 四舍五入取整

 pow(x,y) 计算x的y次方

 max()  获取一组数字最大值，需要提供多个数字，暂时不能使用数组

 min()  获取一组数字最小值，需要提供多个数字，暂时不能使用数组

 random()  获取一个随机数，范围0~1之间  >=0  <1

  获取数组的随机下标：  向下取整( 随机数*数组长度 )  

**Date对象**

用于日期时间的存储和计算

 1.创建

  new Date('2022/3/16 14:12:30')

  new Date(2022,2,16,14,12,30)  //1~12月份存储的值 0~11

  new Date()  存储的是当前操作系统的时间

  new Date(1000)  存储的是距离计算机元年（1970-1-1 0:0:0）的毫秒数，会产生一个具体的日期时间 —— 时间戳

 2.获取存储的值

  getFullYear()/getMonth()/getDate()

​        月份的值0~11，使用的时候需要加1

  getHours()/getMinutes()/getSeconds()/getMilliseconds()

​     时   分      秒      毫秒

  getTime() 获取时间戳

  getDay() 获取星期，范围是0~6 对应的是日~六

3.获取本地字符串格式

 用于调节阶段；存在兼容性问题，不能用于实际开发中

 toLocaleString() 获取完整的部分

 toLocaleDateString() 获取日期部分

 toLocaleTimeString() 获取时间部分

 4.修改日期时间

  setFullYear()/setMonth()/setDate()

​        月份的值0~11

  setHours()/setMinutes()/setSeconds()/setMilliseconds()

​     时   分      秒      毫秒

  setTime()  修改时间戳，会产生一个新的日期时间

  说明：不能修改星期